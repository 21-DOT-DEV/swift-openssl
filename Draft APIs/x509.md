# X.509 Certificate & SHA-384 Specification

> **Parent:** [overview.md](overview.md)  
> **Status:** Draft  

## Overview

Minimal X.509 certificate wrapper and SHA-384 hash function addition to support RSA-PSS and CT verification. The X.509 type is intentionally minimal â€” sufficient for key extraction and SCT parsing, but not a full certificate validation API.

---

## X.509 Namespace

```swift
extension OpenSSL {
    /// X.509 certificate operations.
    public enum X509 {}
}
```

---

## Certificate Type

```swift
extension OpenSSL.X509 {
    /// An X.509 certificate.
    public struct Certificate: Sendable {
        // Internal: OpenSSL X509* handle (wrapped for memory safety)
        
        /// Creates a certificate from PEM-encoded data.
        /// - Parameter pemRepresentation: The PEM-encoded certificate.
        /// - Throws: `OpenSSLError.invalidCertificate` if parsing fails.
        public init(pemRepresentation: String) throws
        
        /// Creates a certificate from DER-encoded data.
        /// - Parameter derRepresentation: The DER-encoded certificate.
        /// - Throws: `OpenSSLError.invalidCertificate` if parsing fails.
        public init<D: DataProtocol>(derRepresentation: D) throws
        
        /// The certificate's not-before date.
        public var notBefore: Date { get }
        
        /// The certificate's not-after date.
        public var notAfter: Date { get }
        
        /// The certificate's subject common name.
        public var subjectCommonName: String? { get }
        
        /// The certificate's issuer common name.
        public var issuerCommonName: String? { get }
        
        /// The certificate's serial number as hexadecimal string.
        public var serialNumber: String { get }
        
        /// The DER-encoded certificate.
        public var derRepresentation: Data { get }
        
        /// The PEM-encoded certificate.
        public var pemRepresentation: String { get }
        
        /// Whether the certificate is currently valid (now is within validity period).
        public var isCurrentlyValid: Bool {
            let now = Date()
            return now >= notBefore && now <= notAfter
        }
        
        /// The certificate's validity period in days.
        public var validityPeriodDays: Int {
            Int(notAfter.timeIntervalSince(notBefore) / 86400)
        }
    }
}
```

### Public Key Extraction

```swift
extension OpenSSL.X509.Certificate {
    /// The type of public key in the certificate.
    public enum PublicKeyType: Sendable {
        case rsa
        case rsaPSS
        case ecdsa
        case ed25519
        case unknown
    }
    
    /// The type of public key contained in this certificate.
    public var publicKeyType: PublicKeyType { get }
    
    /// Extracts the RSA public key for PSS verification.
    /// - Returns: The RSA public key, or `nil` if the certificate doesn't contain an RSA key.
    public var rsaPSSPublicKey: OpenSSL.RSA.PSS.PublicKey? { get }
    
    /// The DER-encoded SubjectPublicKeyInfo.
    public var subjectPublicKeyInfo: Data { get }
}
```

---

## SHA-384 Addition

### Digest Type

```swift
extension OpenSSL.SHA {
    /// A SHA384 digest result.
    public struct SHA384Digest: Sendable, Equatable {
        /// The raw digest bytes (48 bytes).
        public let rawValue: Data
        
        /// The byte count of a SHA384 digest (48 bytes).
        public static let byteCount = 48
        
        /// Creates a digest from raw bytes.
        /// - Parameter rawValue: The 48-byte digest.
        /// - Throws: `OpenSSLError.invalidInput` if the data is not 48 bytes.
        public init(rawValue: Data) throws {
            guard rawValue.count == Self.byteCount else {
                throw OpenSSLError.invalidInput("SHA384 digest must be 48 bytes")
            }
            self.rawValue = rawValue
        }
        
        /// Creates a digest from raw bytes without validation (internal use).
        internal init(unchecked rawValue: Data) {
            self.rawValue = rawValue
        }
        
        /// Returns the digest as a lowercase hexadecimal string.
        public var hexString: String {
            rawValue.map { String(format: "%02x", $0) }.joined()
        }
    }
}
```

### Hash Functions

```swift
extension OpenSSL.SHA {
    /// Computes the SHA384 hash of the given data.
    /// - Parameter data: The data to hash.
    /// - Returns: The SHA384 digest.
    public static func sha384(data: Data) -> SHA384Digest
    
    /// Computes the SHA384 hash of the given string.
    /// - Parameter string: The string to hash (UTF-8 encoded).
    /// - Returns: The SHA384 digest.
    public static func sha384(string: String) -> SHA384Digest {
        sha384(data: Data(string.utf8))
    }
    
    /// Computes the SHA384 hash of the given bytes.
    /// - Parameter bytes: The bytes to hash.
    /// - Returns: The SHA384 digest.
    public static func sha384<D: DataProtocol>(bytes: D) -> SHA384Digest {
        sha384(data: Data(bytes))
    }
}
```

---

## Usage Examples

### Certificate Parsing

```swift
import OpenSSL

// Parse from PEM
let cert = try OpenSSL.X509.Certificate(pemRepresentation: """
-----BEGIN CERTIFICATE-----
MIIDdzCCAl+gAwIBAgIEAgAAuTANBgkqhkiG9w0BAQsFADBaMQswCQYD...
-----END CERTIFICATE-----
""")

print("Subject: \(cert.subjectCommonName ?? "unknown")")
print("Valid: \(cert.notBefore) to \(cert.notAfter)")
print("Currently valid: \(cert.isCurrentlyValid)")
print("Validity period: \(cert.validityPeriodDays) days")
```

### Extract RSA Key for Verification

```swift
// Extract RSA public key from certificate
if let rsaKey = cert.rsaPSSPublicKey {
    let signature = OpenSSL.RSA.PSS.Signature(rawRepresentation: sigData)
    let isValid = rsaKey.isValidSignature(signature, for: messageData)
    print("Signature valid: \(isValid)")
} else {
    print("Certificate does not contain an RSA key")
}
```

### SHA-384 Hashing

```swift
// Hash data
let digest = OpenSSL.SHA.sha384(data: someData)
print("SHA384: \(digest.hexString)")

// Hash string
let stringDigest = OpenSSL.SHA.sha384(string: "Hello, World!")
print("SHA384: \(stringDigest.hexString)")

// Compare digests
let digest1 = OpenSSL.SHA.sha384(string: "test")
let digest2 = OpenSSL.SHA.sha384(string: "test")
assert(digest1 == digest2)
```

---

## OpenSSL Function Mapping

| Swift API | OpenSSL Functions |
|-----------|-------------------|
| `Certificate(pemRepresentation:)` | `BIO_new_mem_buf`, `PEM_read_bio_X509` |
| `Certificate(derRepresentation:)` | `d2i_X509` |
| `notBefore` | `X509_get_notBefore`, `ASN1_TIME_to_tm` |
| `notAfter` | `X509_get_notAfter`, `ASN1_TIME_to_tm` |
| `subjectCommonName` | `X509_get_subject_name`, `X509_NAME_get_text_by_NID(NID_commonName)` |
| `issuerCommonName` | `X509_get_issuer_name`, `X509_NAME_get_text_by_NID(NID_commonName)` |
| `serialNumber` | `X509_get_serialNumber`, `ASN1_INTEGER_to_BN`, `BN_bn2hex` |
| `derRepresentation` | `i2d_X509` |
| `pemRepresentation` | `PEM_write_bio_X509` |
| `publicKeyType` | `X509_get_pubkey`, `EVP_PKEY_get_base_id` |
| `rsaPSSPublicKey` | `X509_get_pubkey` (returns EVP_PKEY*) |
| `subjectPublicKeyInfo` | `i2d_PUBKEY` |
| `sha384(data:)` | `SHA384()` or `EVP_Digest(EVP_sha384())` |

---

## Implementation Notes

### Certificate Memory Management

```swift
// Internal wrapper for X509* pointer
internal final class X509Pointer: @unchecked Sendable {
    let pointer: OpaquePointer  // X509*
    
    init(pointer: OpaquePointer) {
        self.pointer = pointer
    }
    
    deinit {
        X509_free(pointer)
    }
}

// Certificate struct holds reference-counted wrapper
extension OpenSSL.X509.Certificate {
    private let handle: X509Pointer
    
    // All accessors use handle.pointer
}
```

### Date Conversion

OpenSSL uses `ASN1_TIME` for certificate dates. Convert via:

```c
// C implementation sketch
struct tm tm_result;
ASN1_TIME_to_tm(asn1_time, &tm_result);
time_t unix_time = timegm(&tm_result);
// Convert to Swift Date
```

### Future Extensions

This minimal X.509 API can be extended with:
- Subject Alternative Names (SANs)
- Key usage / extended key usage
- Certificate chain building and validation
- CRL / OCSP status checking
